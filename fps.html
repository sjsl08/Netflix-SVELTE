<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Metaverse Experience</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>

<script>
// Set up the scene, camera, and renderer
let scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

let camera = new THREE.PerspectiveCamera(
    75, window.innerWidth/window.innerHeight, 0.1, 1000
);

let renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Add lighting
let ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

let pointLight = new THREE.PointLight(0xff0000, 1, 100);
pointLight.position.set(0, 10, 0);
scene.add(pointLight);

// Create a floor
let floorGeometry = new THREE.PlaneGeometry(100, 100, 10, 10);
let floorMaterial = new THREE.MeshStandardMaterial({ color: 0x123456, wireframe: false });
let floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

// Add some cubes to interact with
let cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
let cubeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });

for (let i = 0; i < 50; i++) {
    let cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    cube.position.set(
        (Math.random() - 0.5) * 50,
        1,
        (Math.random() - 0.5) * 50
    );
    scene.add(cube);
}

// Add crazy animations and visual effects
let clock = new THREE.Clock();

// Particle system
let particlesGeometry = new THREE.BufferGeometry();
let particlesCount = 5000;
let posArray = new Float32Array(particlesCount * 3);

for (let i = 0; i < particlesCount * 3; i++) {
    posArray[i] = (Math.random() - 0.5) * 100;
}

particlesGeometry.setAttribute(
    'position',
    new THREE.BufferAttribute(posArray, 3)
);

let particlesMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.1,
    transparent: true,
    blending: THREE.AdditiveBlending
});

let particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
scene.add(particlesMesh);

// Set up controls
let controls = new PointerLockControls(camera, document.body);

document.addEventListener('click', () => {
    controls.lock();
}, false);

// Movement variables
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;

let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();

let onKeyDown = function (event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = true;
            break;

        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = true;
            break;

        case 'ArrowDown':
        case 'KeyS':
            moveBackward = true;
            break;

        case 'ArrowRight':
        case 'KeyD':
            moveRight = true;
            break;
    }
};

let onKeyUp = function (event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = false;
            break;

        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = false;
            break;

        case 'ArrowDown':
        case 'KeyS':
            moveBackward = false;
            break;

        case 'ArrowRight':
        case 'KeyD':
            moveRight = false;
            break;
    }
};

document.addEventListener('keydown', onKeyDown, false);
document.addEventListener('keyup', onKeyUp, false);

// Animate the scene
function animate() {
    requestAnimationFrame(animate);

    let delta = clock.getDelta();

    // Update particle system
    particlesMesh.rotation.y += 0.002;

    // Movement controls
    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;

    direction.z = Number(moveForward) - Number(moveBackward);
    direction.x = Number(moveRight) - Number(moveLeft);
    direction.normalize();

    if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
    if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

    controls.moveRight(-velocity.x * delta);
    controls.moveForward(-velocity.z * delta);

    // Rotate cubes
    scene.traverse(function (object) {
        if (object.isMesh && object.geometry.type === 'BoxGeometry') {
            object.rotation.x += delta * 0.5;
            object.rotation.y += delta * 0.5;
        }
    });

    renderer.render(scene, camera);
}

animate();

// Handle window resize
window.addEventListener('resize', function () {
    let width = window.innerWidth;
    let height = window.innerHeight;

    renderer.setSize(width, height);

    camera.aspect = width / height;
    camera.updateProjectionMatrix();
});
</script>

</body>
</html>
